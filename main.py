
import discord
from discord.ext import commands
from discord import ui
import asyncio
import os
from dotenv import load_dotenv
import sqlite3

# --- Your Seller Information (Edit Here) ---
SELLER_INFO = {
    "name": "Tu·∫•n Th·∫£o Real",
    "contact_fb": "https://www.facebook.com/tuanthaoreal",
    "contact_zalo": "https://zalo.me/0367361316",
    "avatar_url": "https://i.postimg.cc/FspLSTJc/avatar.png"  # URL to your avatar image
}

# --- Database Setup & Functions ---
def init_db():
    conn = sqlite3.connect('database.db')
    cursor = conn.cursor()
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS products (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        code TEXT NOT NULL UNIQUE,
        description TEXT NOT NULL,
        image_urls TEXT NOT NULL,
        price INTEGER NOT NULL,
        shop_url TEXT
    )
    """)
    conn.commit()
    conn.close()

def get_product_by_code(code):
    conn = sqlite3.connect('database.db')
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM products WHERE lower(code) = ?", (code.lower(),))
    product = cursor.fetchone()
    conn.close()
    return dict(product) if product else None

def get_new_product_code():
    conn = sqlite3.connect('database.db')
    cursor = conn.cursor()
    cursor.execute("SELECT code FROM products ORDER BY id DESC LIMIT 1")
    last_code = cursor.fetchone()
    conn.close()
    if not last_code or not last_code[0]:
        return "P001"
    last_num = int(last_code[0][1:])
    return f"P{last_num + 1:03d}"

# --- Data Loading ---
load_dotenv()
DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")

price_map = {
    "1": ("100.000‚Ç´ ‚Üí 500.000‚Ç´", 100_000, 500_000),
    "2": ("500.000‚Ç´ ‚Üí 1.000.000‚Ç´", 500_001, 1_000_000),
    "3": ("1.000.000‚Ç´ ‚Üí 3.000.000‚Ç´", 1_000_001, 3_000_000),
    "4": ("Tr√™n 3.000.000‚Ç´", 3_000_001, float('inf')),
}

# --- Bot & UI Components ---
intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix='!', intents=intents)

# --- CUSTOMER UI VIEWS ---
class ProductGalleryView(ui.View):
    def __init__(self, product):
        super().__init__(timeout=300)
        self.product = product
        self.image_urls = product['image_urls'].split()
        self.current_page = 0

        self.update_buttons()
        # Add Shop, Facebook, and Zalo buttons
        if self.product['shop_url']:
            self.add_item(ui.Button(label="üõí Mua ngay", style=discord.ButtonStyle.success, url=self.product['shop_url'], row=1))
        self.add_item(ui.Button(label="üí¨ Facebook", style=discord.ButtonStyle.link, url=SELLER_INFO['contact_fb'], row=1))
        self.add_item(ui.Button(label="üí¨ Zalo", style=discord.ButtonStyle.link, url=SELLER_INFO['contact_zalo'], row=1))

    def update_buttons(self):
        for item in self.children[:]:
            if isinstance(item, ui.Button) and item.custom_id in ["prev_page", "next_page"]:
                self.remove_item(item)

        prev_button = ui.Button(label="< Tr∆∞·ªõc", style=discord.ButtonStyle.secondary, custom_id="prev_page", row=0, disabled=(self.current_page == 0))
        next_button = ui.Button(label="Sau >", style=discord.ButtonStyle.secondary, custom_id="next_page", row=0, disabled=(self.current_page == len(self.image_urls) - 1))
        
        prev_button.callback = self.on_page
        next_button.callback = self.on_page

        self.add_item(prev_button)
        self.add_item(next_button)

    def create_embed(self):
        # Display price prominently in the description
        description_with_price = f"**Gi√° b√°n: {self.product['price']:,}‚Ç´**\n\n{self.product['description']}"

        embed = discord.Embed(title=f"Th√¥ng tin s·∫£n ph·∫©m: `{self.product['code']}`", description=description_with_price, color=0x6A0DAD)
        embed.set_author(name=f"Cung c·∫•p b·ªüi: {SELLER_INFO['name']}", icon_url=SELLER_INFO['avatar_url'])
        embed.set_image(url=self.image_urls[self.current_page])
        embed.set_footer(text=f"H√¨nh {self.current_page + 1}/{len(self.image_urls)}")
        return embed

    async def on_page(self, interaction: discord.Interaction):
        if interaction.data["custom_id"] == "next_page":
            self.current_page += 1
        else:
            self.current_page -= 1
        
        self.update_buttons()
        await interaction.response.edit_message(embed=self.create_embed(), view=self)

class ProductSelectionView(ui.View):
    def __init__(self, matched_products):
        super().__init__(timeout=300)
        for product in matched_products:
            self.add_item(ProductButton(product['code']))

class ProductButton(ui.Button):
    def __init__(self, code):
        super().__init__(label=code, style=discord.ButtonStyle.secondary, custom_id=f"product_{code}")

    async def callback(self, interaction: discord.Interaction):
        await interaction.response.defer(thinking=True, ephemeral=True)
        product = get_product_by_code(self.label)
        if not product:
            return await interaction.followup.send("L·ªói: Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m n√†y.", ephemeral=True)
        
        view = ProductGalleryView(product)
        await interaction.followup.send(embed=view.create_embed(), view=view, ephemeral=True)

class PriceRangeView(ui.View):
    def __init__(self):
        super().__init__(timeout=300)
        for key, (label, _, _) in price_map.items():
            self.add_item(PriceButton(key, label))

class PriceButton(ui.Button):
    def __init__(self, price_key, label):
        super().__init__(label=label, style=discord.ButtonStyle.primary, custom_id=f"price_{price_key}")

    async def callback(self, interaction: discord.Interaction):
        await interaction.response.defer(thinking=True, ephemeral=True)
        _, min_p, max_p = price_map[self.custom_id.split('_')[1]]
        conn = sqlite3.connect('database.db')
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        cursor.execute("SELECT code FROM products WHERE price >= ? AND price <= ?", (min_p, max_p))
        matched = cursor.fetchall()
        conn.close()
        if not matched:
            return await interaction.followup.send("üò• R·∫•t ti·∫øc, kh√¥ng c√≥ s·∫£n ph·∫©m n√†o trong kho·∫£ng gi√° n√†y.", ephemeral=True)
        await interaction.followup.send(f"üîé T√¨m th·∫•y {len(matched)} s·∫£n ph·∫©m. Vui l√≤ng ch·ªçn m·ªôt m√£:", view=ProductSelectionView(matched), ephemeral=True)

class StartView(ui.View):
    def __init__(self):
        super().__init__(timeout=60)

    @ui.button(label="B·∫Øt ƒë·∫ßu xem s·∫£n ph·∫©m", style=discord.ButtonStyle.success)
    async def confirm(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.send_message(embed=discord.Embed(title="üå∏ Vui l√≤ng ch·ªçn kho·∫£ng gi√° üå∏", color=0xFF69B4), view=PriceRangeView(), ephemeral=True)
        self.stop()

    @ui.button(label="Kh√¥ng, c·∫£m ∆°n", style=discord.ButtonStyle.secondary)
    async def cancel(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.send_message("üëç OK, m√¨nh ·ªü ƒë√¢y n·∫øu b·∫°n c·∫ßn h·ªó tr·ª£.", ephemeral=True)
        self.stop()

# --- Bot Events & Customer Commands ---
@bot.event
async def on_ready():
    print(f"Logged in as {bot.user} (ID: {bot.user.id})")
    print("------")

@bot.command()
async def hi(ctx):
    await ctx.send(embed=discord.Embed(title="üëã Xin ch√†o! M√¨nh l√† Bot H·ªó Tr·ª£.", description="B·∫°n c√≥ mu·ªën b·∫Øt ƒë·∫ßu t√¨m s·∫£n ph·∫©m kh√¥ng?", color=0x00FFAA), view=StartView())

# --- ADMIN COMMANDS ---
@bot.group()
@commands.is_owner()
async def admin(ctx):
    if ctx.invoked_subcommand is None:
        await ctx.send('L·ªánh admin kh√¥ng h·ª£p l·ªá. Th·ª≠ `!admin add`, `!admin del <code>`, ho·∫∑c `!admin list`.', ephemeral=True)

@admin.error
async def admin_error(ctx, error):
    if isinstance(error, commands.NotOwner):
        await ctx.send("‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.", ephemeral=True)
    else:
        await ctx.send(f"ƒê√£ c√≥ l·ªói x·∫£y ra: {error}", ephemeral=True)

@admin.command(name='add')
async def add_product(ctx):
    def check(m):
        return isinstance(m.channel, discord.DMChannel) and m.author == ctx.author

    try:
        await ctx.author.send("**B·∫Øt ƒë·∫ßu th√™m s·∫£n ph·∫©m m·ªõi...**\n\n**(1/4)** Vui l√≤ng g·ª≠i **th√¥ng tin/m√¥ t·∫£** cho s·∫£n ph·∫©m:")
        desc_msg = await bot.wait_for('message', check=check, timeout=300)
        description = desc_msg.content

        await ctx.author.send("**(2/4)** Vui l√≤ng g·ª≠i c√°c **·∫£nh** cho s·∫£n ph·∫©m. B·∫°n c√≥ th·ªÉ **t·∫£i ·∫£nh l√™n t·ª´ m√°y** ho·∫∑c **d√°n link ·∫£nh** v√†o ƒë√¢y. (·∫¢nh ƒë·∫ßu ti√™n s·∫Ω l√† ·∫£nh ƒë·∫°i di·ªán):")
        images_msg = await bot.wait_for('message', check=check, timeout=300)
        
        image_urls_list = []
        if images_msg.attachments:
            for attachment in images_msg.attachments:
                image_urls_list.append(attachment.url)
        if images_msg.content:
            potential_urls = images_msg.content.split()
            for url in potential_urls:
                if url.startswith('http'):
                    image_urls_list.append(url)

        if not image_urls_list:
            await ctx.author.send("‚ùå Kh√¥ng c√≥ ·∫£nh n√†o ƒë∆∞·ª£c cung c·∫•p. Vui l√≤ng th·ª≠ l·∫°i v·ªõi `!admin add`.")
            return
        image_urls_str = " ".join(image_urls_list)

        await ctx.author.send("**(3/4)** Vui l√≤ng g·ª≠i **gi√° b√°n** c·ªßa s·∫£n ph·∫©m (ch·ªâ nh·∫≠p s·ªë, v√≠ d·ª•: `1500000`):")
        price_msg = await bot.wait_for('message', check=check, timeout=300)
        price = int(price_msg.content)

        await ctx.author.send("**(4/4)** Vui l√≤ng g·ª≠i **link web shop** cho s·∫£n ph·∫©m (n·∫øu kh√¥ng c√≥, g√µ `kh√¥ng`):")
        shop_url_msg = await bot.wait_for('message', check=check, timeout=300)
        shop_url = shop_url_msg.content if shop_url_msg.content.lower() not in ['kh√¥ng', 'ko', 'khong'] else None

        new_code = get_new_product_code()
        conn = sqlite3.connect('database.db')
        cursor = conn.cursor()
        cursor.execute("INSERT INTO products (code, description, image_urls, price, shop_url) VALUES (?, ?, ?, ?, ?)", (new_code, description, image_urls_str, price, shop_url))
        conn.commit()
        conn.close()

        embed = discord.Embed(title="‚úÖ Th√™m s·∫£n ph·∫©m th√†nh c√¥ng!", color=0x00FF00)
        embed.add_field(name="M√£ s·∫£n ph·∫©m", value=new_code, inline=False)
        embed.add_field(name="Gi√° b√°n", value=f"{price:,}‚Ç´", inline=False)
        embed.add_field(name="M√¥ t·∫£", value=description[:1024], inline=False)
        if shop_url:
            embed.add_field(name="Link Shop", value=shop_url, inline=False)
        embed.set_image(url=image_urls_list[0])
        await ctx.author.send(embed=embed)

    except asyncio.TimeoutError:
        await ctx.author.send("‚åõ H·∫øt th·ªùi gian. Vui l√≤ng g√µ `!admin add` ƒë·ªÉ th·ª≠ l·∫°i.")
    except ValueError:
        await ctx.author.send("‚ùå D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p ƒë√∫ng ƒë·ªãnh d·∫°ng. Th·ª≠ l·∫°i v·ªõi `!admin add`.")
    except Exception as e:
        await ctx.author.send(f"ƒê√£ c√≥ l·ªói x·∫£y ra: {e}")

@admin.command(name='del')
async def delete_product(ctx, code: str):
    conn = sqlite3.connect('database.db')
    cursor = conn.cursor()
    cursor.execute("DELETE FROM products WHERE lower(code) = ?", (code.lower(),))
    changes = conn.total_changes
    conn.commit()
    conn.close()

    if changes > 0:
        await ctx.send(f"üóëÔ∏è ƒê√£ x√≥a th√†nh c√¥ng s·∫£n ph·∫©m c√≥ m√£ `{code}`.", ephemeral=True)
    else:
        await ctx.send(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m n√†o c√≥ m√£ `{code}`.", ephemeral=True)

@admin.command(name='list')
async def list_products(ctx):
    conn = sqlite3.connect('database.db')
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    cursor.execute("SELECT code, price, description, image_urls, shop_url FROM products ORDER BY id")
    products = cursor.fetchall()
    conn.close()

    if not products:
        return await ctx.send("üì≠ Database tr·ªëng, ch∆∞a c√≥ s·∫£n ph·∫©m n√†o.", ephemeral=True)

    pages = []
    current_page = ""
    for p in products:
        first_image = p['image_urls'].split()[0] if p['image_urls'] else ''
        shop_link_text = f" - [Shop]({p['shop_url']})" if p['shop_url'] else ""
        line = f"**- `{p['code']}`**: {p['price']:,}‚Ç´ ([·∫¢nh]({first_image})){shop_link_text}\n*M√¥ t·∫£: {p['description'][:70]}...*\n\n"
        if len(current_page) + len(line) > 1000:
            pages.append(current_page)
            current_page = ""
        current_page += line
    pages.append(current_page)

    for i, page_content in enumerate(pages):
        embed = discord.Embed(title=f"üì¶ Danh s√°ch s·∫£n ph·∫©m ({len(products)}) - Trang {i+1}/{len(pages)}", description=page_content, color=0x3498db)
        await ctx.send(embed=embed, ephemeral=True)

# --- Main Execution Logic ---
async def main():
    # Reset database on start for development to apply new schema
    if os.path.exists('database.db'):
        # We only need to do this if the schema changes. Since the last change added shop_url,
        # we can comment this out for now to avoid data loss on every restart.
        # os.remove('database.db') 
        # print("Old database removed to apply new schema.")
        pass
    
    init_db() # This will create the table if it doesn't exist, safe to run.
    print("Database initialized.")
    
    if DISCORD_TOKEN:
        async with bot:
            print("Starting bot...")
            await bot.start(DISCORD_TOKEN)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("Bot shutdown gracefully.")
